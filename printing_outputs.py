# Project 3 - this module will implement various outputs and each kind of
# output that is generated by the program must be implemented as a separate
# class

from handle_mq_api import create_elevationURL, open_and_encode, convert_webpage_to_JSON

class error_message:          ## Catches if any route is not found
                              ## or if the url is invalid
    def display(self, jason: str):
        official_jason = convert_webpage_to_JSON(jason)

        if official_jason['route']['routeError']['errorCode'] == 0:
            return ("NO ROUTE FOUND")

        if official_jason == 'The AppKey submitted with this request is invalid':
            return ("MAPQUEST ERROR")
        
class steps:                ## Prints the directions of each location

    def display(self, jason: str):
        official_jason = convert_webpage_to_JSON(jason)

        a = official_jason['route']['legs']

        print('DIRECTIONS')
        
        for every_narrative in a:
            for direct in every_narrative['maneuvers']:
                print(direct["narrative"])


    
class totaltime:            ## Prints the total time of the journey

    def display(self, jason: str):
        official_jason = convert_webpage_to_JSON(jason)
        
        unofficially_official_time = official_jason['route']['time']
        official_time = round(float(unofficially_official_time)/60)  
        
        print('TOTAL TIME: {} minutes'.format(official_time))



class totaldist:            ## Prints the total distance of the journey

    def display(self, jason: str):
        official_jason = convert_webpage_to_JSON(jason)
        unofficially_official_distance = official_jason['route']['distance']
        official_distance = round(float(unofficially_official_distance))

        print('TOTAL DISTANCE: {} miles'.format(official_distance))

         

class latlongs:             ## Prints the latitude and longitude of each location

    def display(self, jason: str):
        official_jason = convert_webpage_to_JSON(jason)

        print('LATLONG')
        
        for location in official_jason['route']['locations']:
            if location["latLng"]["lng"] < 0:
                W_E = abs(location["latLng"]["lng"])
                official_we = 'W'
            if location["latLng"]["lat"] < 0:
                N_S = abs(location["latLng"]["lat"])
                official_ns = 'S'
            if location["latLng"]["lng"] > 0:
                W_E = abs(location["latLng"]["lng"])
                official_we = 'E'
            if location["latLng"]["lat"] > 0:
                N_S = abs(location["latLng"]["lat"])
                official_ns = 'N'
            print('{:.2f}{}  {:.2f}{}'.format(N_S, official_ns, W_E, official_we))


        
    
class elevation:            ## Prints the elevation, uses part of the latlong function
    
    def display(self, jason:str):
        lat_list = []
        
        official_jason =convert_webpage_to_JSON(jason)
        for location in official_jason['route']['locations']:
            if location["latLng"]["lng"] < 0:
                W_E = (location["latLng"]["lng"])
            if location["latLng"]["lat"] < 0:
                N_S = (location["latLng"]["lat"])
            if location["latLng"]["lng"] > 0:
                W_E = (location["latLng"]["lng"])
            if location["latLng"]["lat"] > 0:
                N_S = (location["latLng"]["lat"])
            lat_list.append((N_S, W_E))

        lat = lat_list

        print('ELEVATIONS')
        
        for every in lat:
            a = create_elevationURL(every)
            new_a = open_and_encode(a)
            official_a = convert_webpage_to_JSON(new_a)
            round_up_official_a = round(official_a["elevationProfile"][0]["height"])
            print('{}'.format(round_up_official_a))
            


